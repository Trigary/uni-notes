<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Adatbázisok II: EA-ZH-1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="empty.js" type="text/javascript"></script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head>
<body>
<header id="title-block-header">
<h1 class="title">Adatbázisok II: EA-ZH-1</h1>
</header>


<p>Készült Kiss Attila előadásai alapján.</p>
<p>Sárközi Gergő, 2022-23-1. félév<br />
Nincsen lektorálva!</p>
<section id="fizika-fizika.ppt" class="level1">
<h1>Fizika (fizika.ppt)</h1>
<section id="mit-hívunk-statikus-és-mit-dinamikus-adatbázisnak-1-pont" class="level2">
<h2>1. Mit hívunk statikus, és mit dinamikus adatbázisnak? (1 pont)</h2>
<p><em>1. oldal</em></p>
<p>Statikus: ritkán módosul, a lekérdezések gyorsasága a fontosabb<br />
Dinamikus: gyakran módosul, ritkán végzünk lekérdezéseket</p>
</section>
<section id="fogalmazzunk-meg-3-célt-amire-az-indexelés-kiválasztásánál-figyelni-kell-3-pont" class="level2">
<h2>2. Fogalmazzunk meg 3 célt, amire az indexelés kiválasztásánál figyelni kell! (3 pont)</h2>
<p><em>1. oldal</em></p>
<p>Gyors lekérdezés, gyors adatmódosítás, minél kisebb tárolási méret</p>
</section>
<section id="mit-tételezünk-fel-mivel-arányos-a-beolvasás-kiírás-költsége-1-pont" class="level2">
<h2>3. Mit tételezünk fel, mivel arányos a beolvasás, kiírás költsége? (1 pont)</h2>
<p><em>1. oldal</em></p>
<p>Háttértároló és memória között mozgatott blokkok számával</p>
</section>
<section id="adjuk-meg-az-alábbi-paraméterek-jelentését-l-b-b-t-bf-m-ia-7-pont" class="level2">
<h2>4. Adjuk meg az alábbi paraméterek jelentését! l, b, B, T, bf, M, I(A) (7 pont)</h2>
<p><em>3, 5. oldal</em></p>
<p>l: length, rekordméret bájtokban<br />
b: blokkméret bájtokban<br />
B: fájl mérete blokkokban<br />
T: tuple, rekordok száma<br />
bf: blokkolási faktor, blokkonként hány rekord fér el, <span class="math inline">\(bf=\lfloor b/l \rfloor\)</span><br />
M: memória mérete blokkokban<br />
I(A): képméret, “A” oszlopban szereplő különböző értékek száma</p>
</section>
<section id="adjuk-meg-rxs-méretét-blokkokban-kifejezve-2-pont" class="level2">
<h2>5. Adjuk meg RxS méretét blokkokban kifejezve! (2 pont)</h2>
<p><em>3. oldal</em></p>
<p><span class="math inline">\(B(R \times S) = T(R) * T(S) * (I(R) + I(S)) / b = T(S)*B(R) + T(R)*B(S)\)</span></p>
</section>
<section id="mit-jelent-az-egyenletességi-feltétel-1-pont" class="level2">
<h2>6. Mit jelent az egyenletességi feltétel? (1 pont)</h2>
<p><em>4.oldal</em></p>
<p>Egy <span class="math inline">\(A=a\)</span> feltételt kielégítő rekordokból nagyjából azonos számú szerepel, a konkrét feltételtől függetlenül.</p>
</section>
<section id="mekkora-adategységet-olvas-az-író-olvasó-fej-1-pont" class="level2">
<h2>7. Mekkora adategységet olvas az író-olvasó fej? (1 pont)</h2>
<p><em>1. oldal</em></p>
<p>Egy blokkot.</p>
</section>
<section id="mitől-függhet-a-blokkméret-1-pont" class="level2">
<h2>8. Mitől függhet a blokkméret? (1 pont)</h2>
<p><em>1. oldal</em></p>
<p>Operációs rendszer, hardver, adatbázis-kezelő</p>
</section>
<section id="egyenletességi-feltétel-esetén-hány-blokkból-áll-a-sigma_aar-lekérdezés-eredménye-1-pont" class="level2">
<h2>9. Egyenletességi feltétel esetén hány blokkból áll a <span class="math inline">\(\sigma_{A=a}(R)\)</span> lekérdezés eredménye? (1 pont)</h2>
<p><em>5. oldal</em></p>
<p><span class="math inline">\(B(\sigma_{A=a}(R)) = B(R) / I(A)\)</span></p>
</section>
<section id="soroljunk-fel-legalább-7-különböző-fájlszervezési-módszert-7-pont" class="level2">
<h2>10. Soroljunk fel legalább 7 különböző fájlszervezési módszert? (7 pont)</h2>
<p><em>5. oldal</em></p>
<p>kupac (heap), hasító index (hash), rendezett állomány, elsődleges index (ritka index), másodlagos index (sűrű index), többszintű index, <span class="math inline">\(B^+\)</span>-fa vagy <span class="math inline">\(B^*\)</span> fa</p>
</section>
<section id="kupac-szervezés-esetén-mennyi-a-keresés-költsége-legrosszabb-esetben-1-pont" class="level2">
<h2>11. Kupac szervezés esetén mennyi a keresés költsége legrosszabb esetben? (1 pont)</h2>
<p><em>6. oldal</em></p>
<p><span class="math inline">\(B\)</span> (kupac mérete blokkokban)</p>
</section>
<section id="kupac-szervezés-esetén-mennyi-a-beszúrás-költsége-1-pont" class="level2">
<h2>12. Kupac szervezés esetén mennyi a beszúrás költsége? (1 pont)</h2>
<p><em>6. oldal</em></p>
<p>Utolsó blokkba tesszük a rekordot, tehát 1 olvasás és 1 írás (azaz 2)</p>
</section>
<section id="mit-mond-meg-a-hx-hasító-függvény-értéke-1-pont" class="level2">
<h2>13. Mit mond meg a h(x) hasító függvény értéke? (1 pont)</h2>
<p><em>7. oldal</em></p>
<p>Hogy melyik kosárba tartozik a rekord, amelynek indexmezőjének az értéke <span class="math inline">\(x\)</span>.</p>
</section>
<section id="mikor-jó-egy-hasító-függvény-és-ilyenkor-milyen-hosszúak-a-blokkláncok-2-pont" class="level2">
<h2>14. Mikor jó egy hasító függvény és ilyenkor milyen hosszúak a blokkláncok? (2 pont)</h2>
<p><em>7. oldal</em></p>
<p>Egy jó hasító függvény nagyjából egyenletesen sorolja be a rekordokat különböző kosarakba.<br />
Ilyenkor egy blokklánc <span class="math inline">\(B/K\)</span> blokkból áll, ahol <span class="math inline">\(K\)</span> a blokkláncok száma.</p>
</section>
<section id="mennyi-a-sigma_aar-lekérdezés-keresési-költsége-jó-hasító-index-esetén-1-pont" class="level2">
<h2>15. Mennyi a <span class="math inline">\(\sigma_{A=a}(R)\)</span> lekérdezés keresési költsége jó hasító index esetén? (1 pont)</h2>
<p><em>8. oldal</em></p>
<p>Legyen <span class="math inline">\(K\)</span> a blokkláncok száma.<br />
Ha az indexmező és a keresési mező megegyezik, akkor <span class="math inline">\(B/K\)</span> (<span class="math inline">\(B/K\)</span> méretű kupacban keresés).<br />
Ha a kettő eltér, akkor <span class="math inline">\(B\)</span> (<span class="math inline">\(B\)</span> méretű kupacban keresés).</p>
</section>
<section id="ha-túl-nagynak-választjuk-a-k-t-hasításkor-akkor-ez-milyen-problémát-okozhat-1-pont" class="level2">
<h2>16. Ha túl nagynak választjuk a K-t hasításkor, akkor ez milyen problémát okozhat? (1 pont)</h2>
<p><em>8. oldal</em></p>
<p>Blokkonként sokszor csak 1 rekord lesz tárolva, ami pazarolja a tárhelyet.</p>
</section>
<section id="milyen-keresésre-nem-jó-a-hasító-indexelés-1-pont" class="level2">
<h2>17. Milyen keresésre nem jó a hasító indexelés? (1 pont)</h2>
<p><em>8. oldal</em></p>
<p>Intervallumos <span class="math inline">\((a &lt; A &lt; b)\)</span> típusú keresésre.</p>
</section>
<section id="mit-jelent-a-dinamikus-hasító-indexelés-és-milyen-két-fajtáját-ismerjük-3-pont" class="level2">
<h2>18. Mit jelent a dinamikus hasító indexelés és milyen két fajtáját ismerjük? (3 pont)</h2>
<p><em>11. oldal</em></p>
<p>Jelentése: a kosarak száma beszúráskor, törléskor változhat (nincsen előre rögzítve).<br />
Két tanult fajtája: kiterjeszthető (expandable) és lineáris</p>
</section>
<section id="kiterjeszthető-hasítás-esetén-a-hk-érték-alapján-melyik-kosárba-kerül-a-rekord-2-pont" class="level2">
<h2>19. Kiterjeszthető hasítás esetén a h(K) érték alapján melyik kosárba kerül a rekord? (2 pont)</h2>
<p><em>11. oldal (utolsó bekezdés)</em></p>
<p>Amelynek prefix kódja a <span class="math inline">\(h(K)\)</span> kezdő szelete. (Ha egy kosár kódja <span class="math inline">\(i\)</span> hosszú, akkor <span class="math inline">\(h(K)\)</span> <span class="math inline">\(i\)</span> hosszú kezdő szeletével kell megegyeznie a kódnak.)</p>
<p>Ha beszúrásnál nincs szabad hely a megfelelő kosárban, akkor a kosarat kettő osztjuk, a prefix kódjának a hosszát megnövelve eggyel. A meglévő elemeket az új, hosszabb kód alapján a megfelelő új kosárba helyezzük. Ezt a kettőosztást akár többször meg kell ismételni, amíg nem lesz szabad hely.</p>
</section>
<section id="milyen-probléma-keletkezhet-kiterjeszthető-hasító-index-esetén-és-mi-rá-a-megoldás-2-pont" class="level2">
<h2>20. Milyen probléma keletkezhet kiterjeszthető hasító index esetén és mi rá a megoldás? (2 pont)</h2>
<p><em>13. oldal (utolsó bekezdés) és 14. oldal (első bekezdés)</em></p>
<p>Ha a rekordok hasító értékének eleje sok bitben megegyezik, akkor hosszú (fa) ágak keletkezheznek. A megoldás, hogy a fát egy tömbbel ábrázoljuk. A tömb mérete a kosarak prefix kódjainak hosszának 2-es alapú hatványa (pl. 2 hosszú kód esetén 4 hosszú a tömb). Így a tömb <span class="math inline">\(h(x)\)</span>-edik eleme megmutatja, hogy melyik kosárba való az adott rekord. Több tömb elem is mutathat ugyan arra a kosárra.</p>
</section>
<section id="lineáris-hasító-index-esetén-mikor-nyitunk-meg-új-kosarat-1-pont" class="level2">
<h2>21. Lineáris hasító index esetén mikor nyitunk meg új kosarat? (1 pont)</h2>
<p><em>17. oldal</em></p>
<p>Ha egy előre megadott értéket elér a kosarakra jutó átlagos rekordszám: ha a rekordok száma osztva a kosarak számával átlép egy küszöb értéket.</p>
</section>
<section id="lineáris-hasító-index-esetén-a-hk-érték-alapján-melyik-kosárba-kerül-a-rekord-2-pont" class="level2">
<h2>22. Lineáris hasító index esetén a h(K) érték alapján melyik kosárba kerül a rekord? (2 pont)</h2>
<p><em>17. oldal (utolsó 2 bekezdés)</em></p>
<p>Nézzük <span class="math inline">\(h(K)\)</span> utolsó <span class="math inline">\(\log(n)\)</span> bitjét, ahol <span class="math inline">\(n\)</span> a kosarak száma.<br />
Ha nincs ilyen sorszámú kosár, akkor nézzük azt a kosarat, amelyik sorszáma csak az első bitben tér el.<br />
Ha a kosárban van szabad hely, akkor abba tesszük bele.<br />
Ha nincs szabad hely, akkor a kosárhoz hozzáláncolunk egy új blokkot és abba tesszük bele.</p>
</section>
<section id="rendezett-állomány-esetén-adjuk-meg-a-bináris-logaritmikus-keresés-lépéseit-4-pont" class="level2">
<h2>23. Rendezett állomány esetén adjuk meg a bináris (logaritmikus) keresés lépéseit! (4 pont)</h2>
<p><em>21. oldal (utolsó előtti bekezdés)</em></p>
<ul>
<li>Középső blokk beolvasása</li>
<li>Ha nincs benne az <span class="math inline">\(A=a\)</span> értékű rekord: eldöntjük, hogy a blokklánc első vagy második felében szerepelhet-e</li>
<li>Felezett blokklánc középső blokkjának beolvasásával folytatjuk a folyamatot</li>
<li>Addig ismételjük, amíg megtaláljuk a rekordot vagy a blokklánc már csak 1 blokkból áll</li>
</ul>
</section>
<section id="mennyi-a-keresési-költség-rendezett-mező-esetében-1-pont" class="level2">
<h2>24. Mennyi a keresési költség rendezett mező esetében? (1 pont)</h2>
<p><em>21. oldal (utolsó bekezdés)</em></p>
<p><span class="math inline">\(\log_2(B)\)</span></p>
</section>
<section id="mennyi-a-keresési-költség-rendezett-mező-esetében-ha-gyűjtő-blokkokat-is-használunk-1-pont" class="level2">
<h2>25. Mennyi a keresési költség rendezett mező esetében, ha gyűjtő blokkokat is használunk? (1 pont)</h2>
<p><em>22. oldal (utolsó előtti bekezdés)</em></p>
<p><span class="math inline">\(\log_2(B-G)+G\)</span> ahol <span class="math inline">\(G\)</span> a gyűjtő blokkok száma</p>
</section>
<section id="mennyi-a-keresési-költség-rendezett-mező-esetében-ha-minden-blokkot-félig-üresen-hagyunk-1-pont" class="level2">
<h2>26. Mennyi a keresési költség rendezett mező esetében, ha minden blokkot félig üresen hagyunk? (1 pont)</h2>
<p><em>23. oldal</em></p>
<p><span class="math inline">\(\log_2(2*B)=1+\log_2(B)\)</span></p>
</section>
<section id="milyen-mindig-az-indexrekord-szerkezete-1-pont" class="level2">
<h2>27. Milyen mindig az indexrekord szerkezete? (1 pont)</h2>
<p><em>24. oldal</em></p>
<p>Az indexrekord egy <span class="math inline">\((a,p)\)</span> kettes, ahol <span class="math inline">\(a\)</span> egy érték az indexelt oszlopban és <span class="math inline">\(p\)</span> egy blokkmutató (arra a blokkra mutat, amelyben az <span class="math inline">\(A=a\)</span> értékű rekordot tároljuk).<br />
Az indexrekordok mindig rendezetten vannak tárolva az indexérték szerint.</p>
</section>
<section id="adjuk-meg-az-elsődleges-index-5-jellemzőjét-5-pont" class="level2">
<h2>28. Adjuk meg az elsődleges index 5 jellemzőjét! (5 pont)</h2>
<p><em>25. oldal (1. bekezdés, 5 bajusz)</em></p>
<ul>
<li>Főfájl is az index szempontja szerint rendezett (nem csak az indexfájl)</li>
<li>Csak egy elsődleges index lehet (mert a főfájl csak egy szempont szerint lehet rendezett)</li>
<li>Elég a főfájl minden blokkjának legkisebb rekordjához készíteni egy indexrekordot</li>
<li>Indexrekordok száma: <span class="math inline">\(T(I)=B\)</span> (ritka index)</li>
<li>Indexrekordok kevesebb helyet foglalnak, azaz egy blokkba több fér belőlük, mint főfájl rekordokból: <span class="math inline">\(bf(I) &gt;&gt; bf\)</span></li>
</ul>
</section>
<section id="mit-hívunk-fedőértéknek-1-pont" class="level2">
<h2>29. Mit hívunk fedőértéknek? (1 pont)</h2>
<p><em>25. oldal</em></p>
<p>Legnagyobb olyan indexérték, amely a keresett értéknél kisebb vagy egyenlő.</p>
</section>
<section id="mennyi-a-keresési-költség-elsődleges-index-esetén-1-pont" class="level2">
<h2>30. Mennyi a keresési költség elsődleges index esetén? (1 pont)</h2>
<p><em>25. oldal</em></p>
<p><span class="math inline">\(1+\log_2(B(I))\)</span> ahol <span class="math inline">\(B(I)\)</span> az indexfájl mérete blokkokban.</p>
</section>
<section id="adjuk-meg-a-másodlagos-index-5-jellemzőjét-5-pont" class="level2">
<h2>31. Adjuk meg a másodlagos index 5 jellemzőjét! (5 pont)</h2>
<p><em>33. oldal (1. bekezdés, első 5 bajusz)</em></p>
<ul>
<li>Főfájl rendezetlen (de az indexfájl rendezett)</li>
<li>Több másodlagos index is lehet</li>
<li>Főfájl minden rekordjához kell készíteni egy indexrekordot</li>
<li>Indexrekordok száma: <span class="math inline">\(T(I)=T\)</span> (sűrű index)</li>
<li>Indexrekordok kevesebb helyet foglalnak, azaz egy blokkba több fér belőlük, mint főfájl rekordokból: <span class="math inline">\(bf(I) &gt;&gt; bf\)</span></li>
</ul>
</section>
<section id="hogyan-keresünk-a-másodlagos-indexben-és-mennyi-a-keresés-költsége-5-pont" class="level2">
<h2>32. Hogyan keresünk a másodlagos indexben és mennyi a keresés költsége? (5 pont)</h2>
<p><em>33. oldal (2. bekezdés)</em></p>
<p>Binárist keresést használunk az indexfájlban. A talált indexrekord által mutatott blokkot még be kell olvasnunk, abban van a keresett főfájl rekord.<br />
A keresés költsége: <span class="math inline">\(1+\log_2(B(I))\)</span> ahol <span class="math inline">\(B(I)\)</span> az indexfájl mérete blokkokban<br />
A keresés lassabb, mint elsődleges index esetén, mert több indexrekord létezik (<span class="math inline">\(B(I)\)</span> nagyobb).</p>
</section>
<section id="mit-hívunk-klaszterszervezésű-táblának-1-pont" class="level2">
<h2>33. Mit hívunk klaszterszervezésű táblának? (1 pont)</h2>
<p><em>45. oldal (2. bekezdés)</em></p>
<p>Egy tábla klaszterszervezésű az <span class="math inline">\(A\)</span> oszlopra nézve, ha az <span class="math inline">\(A\)</span> oszlopban azonos értékű sorok azonos vagy egymás utáni blokkokban helyezkednek el, azaz az első találat után az összes többi található fellelhető soros beolvasással.</p>
</section>
<section id="mit-hívunk-klaszterindexnek-1-pont" class="level2">
<h2>34. Mit hívunk klaszterindexnek? (1 pont)</h2>
<p><em>45. oldal (3. bekezdés)</em></p>
<p>Ha egy fájl klaszterszervezésű az <span class="math inline">\(A\)</span> oszlopra nézve, akkor az <span class="math inline">\(A\)</span> oszlop indexe egy klaszterindex.</p>
</section>
<section id="mikor-mondjuk-hogy-2-tábla-klaszterszervezésű-1-pont" class="level2">
<h2>35. Mikor mondjuk, hogy 2 tábla klaszterszervezésű? (1 pont)</h2>
<p><em>45. oldal (4. bekezdés)</em></p>
<p>Ha a táblák közös oszlopain egyező sorok egy blokkban vagy egymás utáni blokkokban helyezkednek el, azaz összekapcsolás során az összetartozó sorok fellelhetők soros beolvasással.</p>
</section>
<section id="ha-t-szintű-indexet-használunk-mennyi-a-keresési-költség-blokkműveletek-számában-mérve-1-pont" class="level2">
<h2>36. Ha t szintű indexet használunk, mennyi a keresési költség blokkműveletek számában mérve? (1 pont)</h2>
<p><em>47. oldal (piros képlet)</em></p>
<p><span class="math inline">\(\log_2(B(I^{(t)}))+t\)</span>, ahol <span class="math inline">\(B(I^{(t)})\)</span> a <span class="math inline">\(t\)</span>-edik szinten található blokkok száma. Ha ezen a szinten csak 1 blokk van, akkor a keresési költség <span class="math inline">\(t+1\)</span>.</p>
</section>
<section id="ha-t-szintű-indexet-használunk-a-legfelső-szinten-milyen-keresést-használunk-1-pont" class="level2">
<h2>37. Ha t szintű indexet használunk, a legfelső szinten milyen keresést használunk? (1 pont)</h2>
<p><em>47. oldal (2. bekezdés, 1. pont)</em></p>
<p>Bináris (logaritmikus) keresést.</p>
</section>
<section id="ha-t-szintű-indexet-használunk-és-a-legfelső-szint-1-blokkból-áll-akkor-mennyi-a-keresési-költség-1-pont" class="level2">
<h2>38. Ha t szintű indexet használunk és a legfelső szint 1 blokkból áll, akkor mennyi a keresési költség? (1 pont)</h2>
<p><em>47. oldal (2. bekezdés, 3. pont)</em></p>
<p><span class="math inline">\(t+1\)</span></p>
</section>
<section id="ha-t-szintű-indexet-használunk-mennyi-az-indexszintek-blokkolási-faktora-és-miért-2-pont" class="level2">
<h2>39. Ha t szintű indexet használunk, mennyi az indexszintek blokkolási faktora és miért? (2 pont)</h2>
<p><em>47. oldal (2. bekezdés, 4. pont)</em></p>
<p>Minden szintnek azonos a blokkolási faktora (<span class="math inline">\(bf(I)\)</span>), mert az indexrekordok hossza megegyezik. (Az indexrekordok egy <span class="math inline">\(A\)</span> oszlop értéket és egy blokkmutatót tárolnak. Ezek nem függnek a <span class="math inline">\(t\)</span> értékétől.)</p>
</section>
<section id="ha-t-szintű-indexet-használunk-vezessük-le-hogy-hány-blokkból-áll-a-legfelső-szint-12-pont" class="level2">
<h2>40. Ha t szintű indexet használunk, vezessük le, hogy hány blokkból áll a legfelső szint! (12 pont)</h2>
<p><em>48. oldal (táblázat)</em></p>
<p>A legfelső szint <span class="math inline">\(B/bf(I)^t\)</span> blokkból áll, mert a blokkok száma minden szinten ahányad részére csökken, amennyi indexrekord fér egy blokkba (<span class="math inline">\(bf(I)\)</span>).<br />
A főfájl <span class="math inline">\(B\)</span> blokkból áll, az első szint <span class="math inline">\(B/bf(I)\)</span> blokkból, a második szint <span class="math inline">\(B/bf(I)/bf(I)=B/bf(I)^2\)</span> blokkból, stb.</p>
<p>Az indexfájlok rendezettek, ezért lehet őket elsődleges index-szel indexelni, ami ritka, azaz blokkonként elég egy indexrekord. Ezért kell minden lépésben <span class="math inline">\(bf(I)\)</span>-vel osztani.<br />
Minden szintnek azonos a blokkolási faktora (<span class="math inline">\(bf(I)\)</span>), mert az indexrekordok hossza megegyezik. A rekordok száma szintén <span class="math inline">\(bf(I)\)</span> hányad részére csökken szintenként: főfájlban <span class="math inline">\(T\)</span> rekord van, 1. szinten <span class="math inline">\(B\)</span>, t-edik szinten <span class="math inline">\(B/bf(I)^{t-1}\)</span>.</p>
</section>
<section id="ha-t-szintű-indexet-használunk-és-a-legfelső-szint-1-blokkból-áll-abból-milyen-egyenlet-következik-és-mi-a-megoldása-t-re-2-pont" class="level2">
<h2>41. Ha t szintű indexet használunk, és a legfelső szint 1 blokkból áll, abból milyen egyenlet következik és mi a megoldása t-re? (2 pont)</h2>
<p><em>48. oldal (táblázat alatti 1 pont)</em></p>
<p>Az egyenlet: <span class="math inline">\(1=B/bf(I)^t\)</span><br />
Megoldás: <span class="math inline">\(t=\log_{bf(I)}(B)\)</span></p>
</section>
<section id="mi-a-két-legfontosabb-jellemzője-a-b-faindexnek-2-pont" class="level2">
<h2>42. Mi a két legfontosabb jellemzője a B+-faindexnek? (2 pont)</h2>
<p><em>49. oldal (telítettségre és algoritmusokra utaló mondatok)</em></p>
<p>Többszintű indexelés egy megvalósítása. Egy adott szerkezetű fa, amelyben minden blokk legalább 50%-ban telített. Ezt a telítettséget és a szerkezetet karbantartó algoritmusok biztosítják.</p>
</section>
<section id="egy-példa-alapján-szemléltessük-a-köztes-csúcs-jellemzőit-b-fa-index-esetén-8-pont" class="level2">
<h2>43. Egy példa alapján szemléltessük a köztes csúcs jellemzőit B+-fa index esetén! (8 pont)</h2>
<p><em>50. oldal (minden, ami szerepel rajta)</em></p>
<p><span class="math inline">\(n\)</span> darab indexértéket és <span class="math inline">\(n+1\)</span> darab mutatót tartalmaz. Erre a köztes csúcsra mutat egy másik belső csúcs.</p>
<p>Legyen <span class="math inline">\(k\)</span> egy tetszőleges indexérték egy adott mutató által meghatározott részgráfban.<br />
Legbaloldalibb mutató: <span class="math inline">\(k &lt; \text{első indexérték}\)</span><br />
Középső mutatók: <span class="math inline">\(\text{előző indexérték} \le k &lt; \text{következő indexérték}\)</span><br />
Legjobboldalibb mutató: <span class="math inline">\(\text{utolsó indexérték} \le k\)</span><br />
(Ahhoz, hogy ez egy példa legyen konkrét számokat be kéne helyettesíteni. Rajzolni valószínűleg jó ötlet.)</p>
<p><img src="zh1/fizika-50.png" style="width:40.0%" /></p>
</section>
<section id="egy-példa-alapján-szemléltessük-a-levél-csúcs-jellemzőit-b-fa-index-esetén-5-pont" class="level2">
<h2>44. Egy példa alapján szemléltessük a levél csúcs jellemzőit B+-fa index esetén! (5 pont)</h2>
<p><em>51. oldal (minden, ami szerepel rajta)</em></p>
<p><span class="math inline">\(n\)</span> darab indexértéket és <span class="math inline">\(n+1\)</span> darab mutatót tartalmaz, ahol a +1 mutató sorrendben a következő levélre mutat. Levél csúcsokra egy belső csúcs is mutat.</p>
<p>A többi mutató az indexértékkel megegyező tartalmú rekordra (nem pedig blokkra!) mutat. (Ahhoz, hogy ez egy példa legyen konkrét számokat be kéne helyettesíteni. Rajzolni valószínűleg jó ötlet.)</p>
<p><img src="zh1/fizika-51.png" style="width:30.0%" /></p>
</section>
<section id="mutassunk-példát-mikor-beszúráskor-egy-levélcsúcsot-kettéosztunk-b-fa-index-esetén-5-pont" class="level2">
<h2>45. Mutassunk példát, mikor beszúráskor egy levélcsúcsot kettéosztunk B+-fa index esetén! (5 pont)</h2>
<p><em>53. oldal (mit szúrunk be és a beszúrás előtti, majd utáni két fát kell lerajzolni)</em></p>
<p><img src="zh1/fizika-53.png" style="width:40.0%" /></p>
</section>
<section id="mutassunk-példát-mikor-beszúráskor-egy-köztes-csúcsot-kettéosztunk-b-fa-index-esetén-5-pont" class="level2">
<h2>46. Mutassunk példát, mikor beszúráskor egy köztes csúcsot kettéosztunk B+-fa index esetén! (5 pont)</h2>
<p><em>54. oldal (mit szúrunk be és a beszúrás előtti, majd utáni két fát kell lerajzolni)</em></p>
<p><img src="zh1/fizika-54.png" style="width:40.0%" /></p>
</section>
<section id="mutassunk-példát-mikor-beszúráskor-nő-a-b-fa-index-magassága-5-pont" class="level2">
<h2>47. Mutassunk példát, mikor beszúráskor nő a B+-fa index magassága! (5 pont)</h2>
<p><em>55. oldal (mit szúrunk be és a beszúrás előtti, majd utáni két fát kell lerajzolni)</em></p>
<p><img src="zh1/fizika-55.png" style="width:40.0%" /></p>
</section>
<section id="mutassunk-példát-mikor-törléskor-megszüntetünk-egy-levélcsúcsot-b-fa-index-esetén-5-pont" class="level2">
<h2>48. Mutassunk példát, mikor törléskor megszüntetünk egy levélcsúcsot B+-fa index esetén! (5 pont)</h2>
<p><em>56. oldal (mit törlünk és a törlés előtti, majd utáni két fát kell lerajzolni)</em></p>
<p><img src="zh1/fizika-56.png" style="width:40.0%" /></p>
</section>
<section id="mutassunk-példát-mikor-törléskor-csökken-a-b-fa-index-magassága-5-pont" class="level2">
<h2>49. Mutassunk példát, mikor törléskor csökken a B+-fa index magassága! (5 pont)</h2>
<p><em>58. oldal (mit törlünk és a törlés előtti, majd utáni két fát kell lerajzolni)</em></p>
<p><img src="zh1/fizika-58.png" style="width:40.0%" /></p>
</section>
</section>
<section id="indexek-08-indexek-1.ppt" class="level1">
<h1>Indexek (08-indexek-1.ppt)</h1>
<section id="mutassunk-példát-arra-mikor-egy-kevés-elemszámú-oszlopra-bitmap-indexet-készítünk-2-pont" class="level2">
<h2>50. Mutassunk példát arra, mikor egy kevés elemszámú oszlopra bitmap indexet készítünk! (2 pont)</h2>
<p><em>33. oldal (a tábla, és a régióra készített index)</em></p>
<p>Adatok:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">ID</th>
<th style="text-align: center;">Név</th>
<th style="text-align: center;">Régió</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">101</td>
<td style="text-align: center;">John Smith</td>
<td style="text-align: center;">east</td>
</tr>
<tr class="even">
<td style="text-align: center;">102</td>
<td style="text-align: center;">Robert Williams</td>
<td style="text-align: center;">central</td>
</tr>
<tr class="odd">
<td style="text-align: center;">103</td>
<td style="text-align: center;">Mary Brown</td>
<td style="text-align: center;">west</td>
</tr>
<tr class="even">
<td style="text-align: center;">104</td>
<td style="text-align: center;">Susan Miller</td>
<td style="text-align: center;">central</td>
</tr>
</tbody>
</table>
<p>Bitmap a ‘Régió’ oszlopra:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Régió=‘east’</th>
<th style="text-align: center;">Régió=‘central’</th>
<th style="text-align: center;">Régió=‘west’</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
</section>
<section id="mutassunk-példát-arra-mikor-logikai-feltételek-kiértékelését-bitmap-vektorműveletekre-vezetjük-vissza-7-pont" class="level2">
<h2>51. Mutassunk példát arra, mikor logikai feltételek kiértékelését bitmap vektorműveletekre vezetjük vissza! (7 pont)</h2>
<p><em>34. oldal (a lekérdezés, a vektorműveletek, és a lekérdezés eredménye: az utolsó vektorban az egyesek száma)</em></p>
<p>Lekérdezés: <code>SELECT COUNT(*) FROM CUSTOMER WHERE STATUS='married' AND REGION IN ('central', 'west');</code></p>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">status = ‘married’</th>
<th style="text-align: center;">AND</th>
<th style="text-align: center;">region = ‘central’</th>
<th style="text-align: center;">OR</th>
<th style="text-align: center;">region = ‘west’</th>
<th style="text-align: center;">=</th>
<th style="text-align: center;">status</th>
<th style="text-align: center;">AND</th>
<th style="text-align: center;">region</th>
<th style="text-align: center;">=</th>
<th style="text-align: center;">Eredmény</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">AND</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">OR</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">=</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">AND</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">=</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>Az eredmény az utolsó oszlopban az egyesek száma.</p>
</section>
</section>
<section id="algebrai-optimalizálás-algebrai-opt.ppt" class="level1">
<h1>Algebrai optimalizálás (algebrai opt.ppt)</h1>
<section id="mi-a-lekérdezések-optimalizálásának-a-célja-és-miket-használunk-fel-ehhez-5-pont" class="level2">
<h2>52. Mi a lekérdezések optimalizálásának a célja és miket használunk fel ehhez? (5 pont)</h2>
<p><em>91. oldal (A cél pontos megfogalmazása.)</em></p>
<p>A cél a lekérdezések gyorsabbá tétele a táblakra vonatkozó paraméterek, statisztikák, indexek ismeretében és általános érvényű tuladonságok, heurisztikák segítségével.</p>
</section>
<section id="adjuk-meg-a-lekérdezések-optimalizálásának-folyamatábráját-19-pont" class="level2">
<h2>53. Adjuk meg a lekérdezések optimalizálásának folyamatábráját! (19 pont)</h2>
<p><em>100. oldal (A folyamatábrán szereplő csúcsok, feliratok mindegyike 1 pont)</em></p>
<p><img src="zh1/algebrai_opt-100.png" style="width:40.0%" /></p>
</section>
<section id="adjuk-meg-egy-egyszerű-relációs-algebrai-kifejezést-és-gráfos-ábrázolását-4-pont" class="level2">
<h2>54. Adjuk meg egy egyszerű relációs algebrai kifejezést és gráfos ábrázolását! (4 pont)</h2>
<p><em>95. oldal (A kifejezés és a gráf)</em></p>
<p>A <span class="math inline">\(\Pi_{B,D}( \sigma_{R.A=&#39;c&#39; \wedge S.E=2 \wedge R.C = S.C} (R \times S) )\)</span> kifejezés gráfként:</p>
<p><img src="zh1/algebrai_opt-95.png" style="width:15.0%" /></p>
</section>
<section id="milyen-költségmodellt-használunk-relációs-algebrai-optimalizálás-esetében-2-pont" class="level2">
<h2>55. Milyen költségmodellt használunk relációs algebrai optimalizálás esetében? (2 pont)</h2>
<p><em>106. oldal (Költségmodell)</em></p>
<p>A kiszámítás költsége arányos a relációs algebrai kifejezés részkifejezéseinek megfelelő relációk tárolási méreteinek összegével.</p>
</section>
<section id="mi-a-módszer-lényege-relációs-algebrai-optimalizálás-esetében-3-pont" class="level2">
<h2>56. Mi a módszer lényege relációs algebrai optimalizálás esetében? (3 pont)</h2>
<p><em>106. oldal (Módszer)</em></p>
<p>Műveletei tulajdonságokon alapuló ekvivalens átalakítások alkalmazása, hogy várhatóan kisebb méretű relációk keletkezzenek.</p>
</section>
<section id="miért-mondjuk-hogy-az-eljárás-heurisztikus-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>57. Miért mondjuk, hogy az eljárás heurisztikus relációs algebrai optimalizálás esetén? (2 pont)</h2>
<p><em>106. oldal (4. pont)</em></p>
<p>Mert az eljárás nem az argumentum relációk valódi méreteivel számol.</p>
</section>
<section id="miért-nem-egyértelmű-az-eredmény-relációs-algebrai-optimalizálás-esetén-4-pont" class="level2">
<h2>58. Miért nem egyértelmű az eredmény relációs algebrai optimalizálás esetén? (4 pont)</h2>
<p><em>106. oldal (4. pont)</em></p>
<p>Mert az átalakítások sorrendje nem determinisztikus, így más sorrendben végrehajtva az átalakításokat más végeredményt kaphatunk. Mindegyik végeredmény általában jobb költségű, mint amiből kiindultunk.</p>
</section>
<section id="a-relációs-algebrai-kifejezésfában-melyek-az-unáris-csúcsok-3-pont" class="level2">
<h2>59. A relációs algebrai kifejezésfában melyek az unáris csúcsok? (3 pont)</h2>
<p><em>107. oldal (unáris csúcsok felsorolása)</em></p>
<p>Unáris csúcsok: <span class="math inline">\(\sigma ,\; \Pi ,\; \rho\)</span> (szelekció, projekció, átnevezés)</p>
</section>
<section id="a-relációs-algebrai-kifejezésfában-melyek-a-bináris-csúcsok-3-pont" class="level2">
<h2>60. A relációs algebrai kifejezésfában melyek a bináris csúcsok? (3 pont)</h2>
<p><em>107. oldal (bináris csúcsok felsorolása)</em></p>
<p>Bináris csúcsok: <span class="math inline">\(- ,\; \cup ,\; \times\)</span> (kivonás, unió, összekapcsolás)</p>
</section>
<section id="a-relációs-algebrai-kifejezésfában-mik-a-levélcsúcsok-2-pont" class="level2">
<h2>61. A relációs algebrai kifejezésfában mik a levélcsúcsok? (2 pont)</h2>
<p><em>107. oldal (kétféle lehet)</em></p>
<p>Levél csúcsok: konstans relációk vagy relációs változók</p>
</section>
<section id="mit-hívunk-ekvivalens-relációs-algebrai-kifejezéseknek-3-pont" class="level2">
<h2>62. Mit hívunk ekvivalens relációs algebrai kifejezéseknek? (3 pont)</h2>
<p><em>110. oldal (1. pont)</em></p>
<p>Két kifejezés ekvivalens, ha tetszőleges relációk esetén azonos eredményeket adnak.</p>
<p><span class="math inline">\(E_1(r_1,...,r_k)\)</span> és <span class="math inline">\(E_2(r_1,...,r_k)\)</span> ekvivalensek (<span class="math inline">\(E_1 \cong E_2\)</span>), ha tetszőleges <span class="math inline">\(r_1, ..., r_k\)</span> relációk esetén <span class="math inline">\(E_1(r_1,...,r_k) = E_2(r_1,...,r_k)\)</span>.</p>
</section>
<section id="hány-szabálycsoportot-adunk-meg-relációs-algebrai-optimalizáláskor-és-mi-jellemző-ezekre-4-pont" class="level2">
<h2>63. Hány szabálycsoportot adunk meg relációs algebrai optimalizáláskor és mi jellemző ezekre? (4 pont)</h2>
<p><em>110. oldal (2. és 3. pont, összesen 4 mondat)</em></p>
<p>11 szabályt (szabálycsoportot) adunk meg. A szabályok kifejezések ekvivalenciáját kimondó bizonyítható állítások.<br />
Az állítások egy részében a kifejezések szintaktikus helyessége egyben elégséges feltétele is az ekvivalenciának.</p>
</section>
<section id="adjuk-meg-a-relációs-algebrai-optimalizálás-kommutatív-szabályait-3-pont" class="level2">
<h2>64. Adjuk meg a relációs algebrai optimalizálás kommutatív szabályait! (3 pont)</h2>
<p><em>110. oldal (3 szabály)</em></p>
<p>1.: Kommutativitás: <span class="math inline">\(E_1 \oplus E_2 \cong E_2 \oplus E_1\)</span> ahol <span class="math inline">\(\oplus \in \{\times, \bowtie, \bowtie_F \}\)</span></p>
</section>
<section id="adjuk-meg-a-relációs-algebrai-optimalizálás-asszociatív-szabályait-3-pont" class="level2">
<h2>65. Adjuk meg a relációs algebrai optimalizálás asszociatív szabályait! (3 pont)</h2>
<p><em>111. oldal (3 szabály)</em></p>
<p>2.: Asszociativitás: <span class="math inline">\((E_1 \oplus E_2) \oplus E_3 \cong E_1 \oplus (E_2 \oplus E_3)\)</span> ahol <span class="math inline">\(\oplus \in \{\times, \bowtie, \bowtie_F\}\)</span></p>
</section>
<section id="adjuk-meg-a-vetítésre-vonatkozó-összevonási-bővítés-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>66. Adjuk meg a vetítésre vonatkozó összevonási, bővítés szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>111. oldal (szabály és feltétel)</em></p>
<p>3.: Vetítések összevonása, bővítése: <span class="math inline">\(\Pi_A(\Pi_B(E)) \cong \Pi_A(E)\)</span> ha <span class="math inline">\(A \subseteq B\)</span></p>
</section>
<section id="adjuk-meg-a-kiválasztások-felcserélhetőségére-felbontására-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-3-pont" class="level2">
<h2>67. Adjuk meg a kiválasztások felcserélhetőségére, felbontására vonatkozó szabályt relációs algebrai optimalizálás esetén! (3 pont)</h2>
<p><em>111. oldal (2 ekvivalencia és feltétel)</em></p>
<p>4.: Kiválasztások felcserélhetősége, felbontása: <span class="math inline">\(\sigma_{F1 \wedge F2}(E) \cong \sigma_{F1}(\sigma_{F2}(E)) \cong \sigma_{F2}(\sigma_{F1}(E))\)</span></p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-vetítés-felcserélhetőségére-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>68. Adjuk meg a kiválasztás és vetítés felcserélhetőségére vonatkozó szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>112. oldal (az a) szabály és feltétele)</em></p>
<p>5.: Kiválasztás és vetítés felcserélhetősége: <span class="math inline">\(\Pi_A(\sigma_F(E)) \cong \sigma_F(\Pi_A(E))\)</span> ahol <span class="math inline">\(F\)</span> csak az <span class="math inline">\(A\)</span> oszlopokat nézi</p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-vetítés-felcserélhetőségére-vonatkozó-általánosított-szabályt-rel.-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>69. Adjuk meg a kiválasztás és vetítés felcserélhetőségére vonatkozó általánosított szabályt rel. algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>112. oldal (a b) szabály és feltétele)</em></p>
<p>5.: Kiválasztás és vetítés felcserélhetősége, általánosabban: <span class="math inline">\(\Pi_A(\sigma_F(E)) \cong \Pi_A(\sigma_F(\Pi_{A \cup B}(E)))\)</span> ahol <span class="math inline">\(F\)</span> az <span class="math inline">\(A \cup B\)</span> oszlopokat nézi és <span class="math inline">\(A \cap B = \emptyset\)</span> (azaz <span class="math inline">\(B\)</span>-t <span class="math inline">\(F\)</span> alapján határozzuk meg)</p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-szorzás-felcserélhetőségére-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>70. Adjuk meg a kiválasztás és szorzás felcserélhetőségére vonatkozó szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>112. oldal (a szabály és feltétele)</em></p>
<p>6.: Kiválasztás és szorzás felcserélhetősége: <span class="math inline">\(\sigma_F(E_1 \times E_2) \cong \sigma_F(E_1) \times E_2\)</span> ahol <span class="math inline">\(F\)</span> csak <span class="math inline">\(E_1\)</span>-et használja</p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-szorzás-felcserélhetőségére-vonatkozó-speciális-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>71. Adjuk meg a kiválasztás és szorzás felcserélhetőségére vonatkozó speciális szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>112. oldal (a speciális szabály és feltétele)</em></p>
<p>6.: Kiválasztás és szorzás felcserélhetősége, speciálisan: <span class="math inline">\(\sigma_F(E_1 \times E_2) \cong \sigma_{F1}(E_1) \times \sigma_{F2}(E_2)\)</span> ahol <span class="math inline">\(F=F1 \wedge F2\)</span> és <span class="math inline">\(Fi\)</span> csak <span class="math inline">\(E_i\)</span>-t ellenőrzi</p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-szorzás-felcserélhetőségére-vonatkozó-általánosított-szabályt-rel.-algebrai-optimalizálás-esetén-3-pont" class="level2">
<h2>72. Adjuk meg a kiválasztás és szorzás felcserélhetőségére vonatkozó általánosított szabályt rel. algebrai optimalizálás esetén! (3 pont)</h2>
<p><em>112. oldal (az általános szabály és feltételei)</em></p>
<p>6.: Kiválasztás és szorzás felcserélhetősége, általánosabban: <span class="math inline">\(\sigma_F(E_1 \times E_2) \cong \sigma_{F2}(\sigma_{F1}(E_1) \times E_2)\)</span> ahol <span class="math inline">\(F=F1 \wedge F2\)</span> és <span class="math inline">\(F1\)</span> csak <span class="math inline">\(E_1\)</span>-et, de <span class="math inline">\(F2\)</span> <span class="math inline">\(E_1 \times E_2\)</span>-t nézi</p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-egyesítés-felcserélhetőségére-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>73. Adjuk meg a kiválasztás és egyesítés felcserélhetőségére vonatkozó szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>113. oldal (a szabály és feltétele)</em></p>
<p>7.: Kiválasztás és egyesítés felcserélhetősége: <span class="math inline">\(\sigma_F(E_1 \cup E_2) \cong \sigma_F(E_1) \cup \sigma_F(E_2)\)</span> ahol <span class="math inline">\(E_i\)</span> azonos sémájú</p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-kivonás-felcserélhetőségére-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>73,5. Adjuk meg a kiválasztás és kivonás felcserélhetőségére vonatkozó szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>113. oldal (de ez nem volt az eredeti kérdéssorban)</em></p>
<p>8.: Kiválasztás és kivonás felcserélhetősége: <span class="math inline">\(\sigma_F(E_1 - E_2) \cong \sigma_F(E_1) - \sigma_F(E_2)\)</span> ahol <span class="math inline">\(E_i\)</span> azonos sémájú</p>
</section>
<section id="adjuk-meg-a-kiválasztás-és-természetes-összekapcsolás-felcserélhetőségére-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>74. Adjuk meg a kiválasztás és természetes összekapcsolás felcserélhetőségére vonatkozó szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>113. oldal (a szabály és feltétele)</em></p>
<p>9.: Kiválasztás és természetes összekapcsolás felcserélhetősége: <span class="math inline">\(\sigma_F(E_1 \bowtie E_2) \cong \sigma_F(E_1) \bowtie \sigma_F(E_2)\)</span> ahol <span class="math inline">\(F\)</span> az <span class="math inline">\(E_i\)</span> közös oszlopain értelmezett</p>
</section>
<section id="adjuk-meg-a-vetítés-és-szorzás-felcserélhetőségére-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>75. Adjuk meg a vetítés és szorzás felcserélhetőségére vonatkozó szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>114. oldal (a szabály és feltétele)</em></p>
<p>10.: Vetítés és szorzás felcserélhetősége: <span class="math inline">\(\Pi_A(E_1 \times E_2) \cong \Pi_{A1}(E_1) \times \Pi_{A2}(E_2)\)</span> ahol <span class="math inline">\(A=A_1 \cup A_2\)</span> és <span class="math inline">\(A_i\)</span> az <span class="math inline">\(E_i\)</span> oszlopainak részhalmaza</p>
</section>
<section id="adjuk-meg-a-vetítés-és-egyesítés-felcserélhetőségére-vonatkozó-szabályt-relációs-algebrai-optimalizálás-esetén-2-pont" class="level2">
<h2>76. Adjuk meg a vetítés és egyesítés felcserélhetőségére vonatkozó szabályt relációs algebrai optimalizálás esetén! (2 pont)</h2>
<p><em>114. oldal (a szabály és feltétele)</em></p>
<p>11.: Vetítés és egyesítés felcserélhetősége: <span class="math inline">\(\Pi_A(E_1 \cup E_2) \cong \Pi_{A}(E_1) \cup \Pi_{A}(E_2)\)</span> ahol <span class="math inline">\(E_i\)</span> sémája azonos és <span class="math inline">\(A\)</span> az oszlopaik egy részhalmaza</p>
</section>
<section id="mutassunk-példát-hogy-a-kivonás-és-a-vetítés-nem-felcserélhető-2-pont" class="level2">
<h2>77. Mutassunk példát, hogy a kivonás és a vetítés nem felcserélhető! (2 pont)</h2>
<p><em>114. oldal (a megjegyzésben leírt példa)</em></p>
<p>Példa <span class="math inline">\(\Pi_A (E_1 - E_2) \ncong \Pi_A (E_1) - \Pi_A (E_2)\)</span> bizonyítására:<br />
Legyen <span class="math inline">\(E_1 = [ \{A=0, B=0\}, \{A=0, B=1\} ]\)</span> és <span class="math inline">\(E_2 = [ \{A=0, B=0\} ]\)</span><br />
Ekkor <span class="math inline">\(\Pi_A(E_1 - E_2) = [ \{A=0\} ]\)</span> de <span class="math inline">\(\Pi_A(E_1) - \Pi_A(E_2) = \emptyset\)</span></p>
</section>
<section id="fogalmazzuk-meg-a-relációs-algebrai-optimalizálás-4-heurisztikus-elvét-4-pont" class="level2">
<h2>78. Fogalmazzuk meg a relációs algebrai optimalizálás 4 heurisztikus elvét! (4 pont)</h2>
<p><em>115. oldal (Vastagon szedett mondatok)</em></p>
<ul>
<li>Minél hamarabb szelektáljunk</li>
<li>Próbáljunk természetes összekapcsolásokat képezni</li>
<li>Vonjuk össze az egymás utáni unáris műveleteket</li>
<li>Keressünk közös részkifejezéseket</li>
</ul>
</section>
<section id="miért-érdemes-hamarabb-szelektálni-relációs-algebrai-optimalizálás-esetén-1-pont" class="level2">
<h2>79. Miért érdemes hamarabb szelektálni relációs algebrai optimalizálás esetén? (1 pont)</h2>
<p><em>115. oldal (1. pont)</em></p>
<p>Hogy a részkifejezések várhatóan kisebb relációk legyenek.</p>
</section>
<section id="miért-érdemes-természetes-összekapcsolásokat-képezni-szorzások-helyett-relációs-algebrai-optimalizálás-esetén-1-pont" class="level2">
<h2>80. Miért érdemes természetes összekapcsolásokat képezni szorzások helyett relációs algebrai optimalizálás esetén? (1 pont)</h2>
<p><em>115. oldal (2. pont)</em></p>
<p>Mert az összekapcsolás hatékonyabban kiszámolható, mint a szorzatból történő kiválasztás.</p>
</section>
<section id="miért-érdemes-az-unáris-műveleteket-összevonni-relációs-algebrai-optimalizálás-esetén-1-pont" class="level2">
<h2>81. Miért érdemes az unáris műveleteket összevonni relációs algebrai optimalizálás esetén? (1 pont)</h2>
<p><em>115. oldal (3. pont)</em></p>
<p>Mert így csökken a műveletek száma, és általában a kiválasztás kisebb relációt eredményez, mint a vetítés.</p>
</section>
<section id="miért-érdemes-a-közös-részkifejezéseket-megkeresni-relációs-algebrai-optimalizálás-esetén-1-pont" class="level2">
<h2>82. Miért érdemes a közös részkifejezéseket megkeresni relációs algebrai optimalizálás esetén? (1 pont)</h2>
<p><em>115. oldal (4. pont)</em></p>
<p>Mert így elég őket csak egyszer kiszámolni a kifejezés kiértékelése során.</p>
</section>
<section id="a-relációs-algebrai-optimalizálás-algoritmusának-mi-az-inputja-és-mi-az-outputja-2-pont" class="level2">
<h2>83. A relációs algebrai optimalizálás algoritmusának mi az inputja és mi az outputja? (2 pont)</h2>
<p><em>116. oldal (input, output)</em></p>
<p>Input: relációs algebrai kifejezés kifejezésfája<br />
Output: optimilizált kifejezésfa optimilizált kiértékelése</p>
</section>
<section id="mi-a-relációs-algebrai-optimalizálás-algoritmusának-1.-lépése-az-alkalmazott-szabályok-felsorolása-nélkül-2-pont" class="level2">
<h2>84. Mi a relációs algebrai optimalizálás algoritmusának 1. lépése (az alkalmazott szabályok felsorolása nélkül)? (2 pont)</h2>
<p><em>116. oldal (1. lépés)</em></p>
<p>Kiválasztások felbontása.</p>
</section>
<section id="mi-a-relációs-algebrai-optimalizálás-algoritmusának-2.-lépése-az-alkalmazott-szabályok-felsorolása-nélkül-2-pont" class="level2">
<h2>85. Mi a relációs algebrai optimalizálás algoritmusának 2. lépése (az alkalmazott szabályok felsorolása nélkül)? (2 pont)</h2>
<p><em>116. oldal (2. lépés)</em></p>
<p>Kiválasztások olyan mélyre vitele a kifejezésfában, amilyen mélyre csak lehetséges.</p>
</section>
<section id="mi-a-relációs-algebrai-optimalizálás-algoritmusának-3.-lépése-az-alkalmazott-szabályok-felsorolása-nélkül-2-pont" class="level2">
<h2>86. Mi a relációs algebrai optimalizálás algoritmusának 3. lépése (az alkalmazott szabályok felsorolása nélkül)? (2 pont)</h2>
<p><em>116. oldal (3. lépés)</em></p>
<p>Vetítések olyan mélyre vitele a kifejezésfában, amilyen mélyre csak lehet.<br />
Olyan vetítések elhagyása, amik a reláció összes attribútumára vetítenek (triviális vetítések).</p>
</section>
<section id="mi-a-relációs-algebrai-optimalizálás-algoritmusának-4.-lépése-az-alkalmazott-szabályok-felsorolása-nélkül-2-pont" class="level2">
<h2>87. Mi a relációs algebrai optimalizálás algoritmusának 4. lépése (az alkalmazott szabályok felsorolása nélkül)? (2 pont)</h2>
<p><em>116. oldal (4. lépés)</em></p>
<p>Közvetlenül egymás utáni kiválasztások vagy vetítések összevonása egy kiválasztássá vagy egy vetítéssé vagy egy kiválasztás utáni vetíttéssé, ha lehet.</p>
</section>
<section id="mi-a-relációs-algebrai-optimalizálás-algoritmusának-5.-lépése-az-alkalmazott-szabályok-felsorolása-nélkül-4-pont" class="level2">
<h2>88. Mi a relációs algebrai optimalizálás algoritmusának 5. lépése (az alkalmazott szabályok felsorolása nélkül)? (4 pont)</h2>
<p><em>116. oldal (5. lépés)</em></p>
<p>Gráf bináris műveletek (<span class="math inline">\(\cup ,\; - ,\; \times\)</span>) alapján részgráfokra bontása. Egy részgráfhoz tartozik még a bináris műveleten végrehajtott kiválasztások és vetítések.</p>
<p>Ha a bináris művelet <span class="math inline">\(\times\)</span> és valamelyik argumentumban nincsen bináris művelet és a művelet részfája equi-joinnak felel meg, akkor az argumentum részfájával egyesíthető a művelet részfája.</p>
</section>
<section id="mi-a-relációs-algebrai-optimalizálás-algoritmusának-6.-lépése-az-alkalmazott-szabályok-felsorolása-nélkül-2-pont" class="level2">
<h2>89. Mi a relációs algebrai optimalizálás algoritmusának 6. lépése (az alkalmazott szabályok felsorolása nélkül)? (2 pont)</h2>
<p><em>116. oldal (6. lépés)</em></p>
<p>Az előző lépésben kapott fa alulról felfelé haladó kiértékelése (tetszőleges sorrendben).</p>
</section>
<section id="adjunk-meg-egy-példát-amiben-a-vetítések-bővítése-trükköt-alkalmazzuk-és-indokoljuk-hogy-mire-jó-ez-8-pont" class="level2">
<h2>90. Adjunk meg egy példát, amiben a vetítések bővítése trükköt alkalmazzuk és indokoljuk, hogy mire jó ez! (8 pont)</h2>
<p><em>122. oldal (a teljes ábra)</em></p>
<p>Ezzel a trükkel a bővített vetítést lejebb vihetjük a kifejezfában, mint az erdeti vetítést lehetne. Ezzel kisebb részeredményeket kaphatunk a kiértékelés során, azaz optimálisabb megoldáshoz juthatunk.</p>
<p><img src="zh1/algebrai_opt-122.png" style="width:35.0%" /></p>
</section>
</section>
<section id="költségbecslés-optimalizálás-optimization.ppt" class="level1">
<h1>Költségbecslés, optimalizálás (optimization.ppt)</h1>
<section id="mennyi-az-scar-szelektivitás-értéke-ha-a-kulcs-1-pont" class="level2">
<h2>91. Mennyi az SC(A,R) szelektivitás értéke, ha A kulcs? (1 pont)</h2>
<p><em>11. oldal</em></p>
<p><span class="math inline">\(SC(A,R) = 1\)</span></p>
</section>
<section id="mennyi-az-scar-szelektivitás-értéke-ha-a-nem-kulcs-a-jelölések-magyarázatát-is-adjuk-meg-1-pont" class="level2">
<h2>92. Mennyi az SC(A,R) szelektivitás értéke, ha A nem kulcs (a jelölések magyarázatát is adjuk meg)? (1 pont)</h2>
<p><em>11. oldal</em></p>
<p><span class="math inline">\(SC(A,R) = N_R / V(A,R)\)</span> ahol <span class="math inline">\(N_R\)</span> az <span class="math inline">\(R\)</span> reláció rekordjainak száma és <span class="math inline">\(V(A,R)\)</span> az <span class="math inline">\(A\)</span> mező különböző értékeinek száma <span class="math inline">\(R\)</span>-ben</p>
</section>
<section id="mennyi-rendezett-táblában-a-bináris-keresés-átlagos-költsége-ha-minden-találatot-be-kell-olvasni-a-jelölések-magyarázatát-is-adjuk-meg-3-pont" class="level2">
<h2>93. Mennyi rendezett táblában a bináris keresés átlagos költsége, ha minden találatot be kell olvasni (a jelölések magyarázatát is adjuk meg)? (3 pont)</h2>
<p><em>13. oldal (bináris átlagos költség, m-re a képlet)</em></p>
<p><span class="math inline">\(\lceil \log_2 B_R \rceil + m\)</span> ahol <span class="math inline">\(m = \lceil SC(A,R) / F_R \rceil - 1\)</span><br />
<span class="math inline">\(m\)</span> adja meg, hogy hány további blokkot kell még megnézni, hogy minden találat meglegyen.<br />
<span class="math inline">\(B_R\)</span> jelentése: <span class="math inline">\(R\)</span> reláció tárolásához szükséges blokkok száma<br />
<span class="math inline">\(SC(A,R)\)</span> jelentése: átlagosan hány <span class="math inline">\(A=a\)</span> mező van <span class="math inline">\(R\)</span>-ben<br />
<span class="math inline">\(F_R\)</span> jelentése: blokkolási tényező, <span class="math inline">\(R\)</span>-ben egy blokkon hány rekord található</p>
</section>
<section id="mennyi-b-fa-típusú-elsődleges-index-esetén-az-átlagos-keresési-költség-ha-minden-találatot-be-kell-olvasni-a-jelölések-magyarázatát-is-adjuk-meg-2-pont" class="level2">
<h2>94. Mennyi B+-fa típusú elsődleges index esetén az átlagos keresési költség, ha minden találatot be kell olvasni (a jelölések magyarázatát is adjuk meg)? (2 pont)</h2>
<p><em>13. oldal (a legutolsó pont)</em></p>
<p><span class="math inline">\(HT_i + \lceil SC(A,R)/F_R \rceil\)</span><br />
<span class="math inline">\(HT_i\)</span> jelentése: <span class="math inline">\(i\)</span> index szintjeinek száma<br />
<span class="math inline">\(SC(A,R)\)</span> jelentése: átlagosan hány <span class="math inline">\(A=a\)</span> mező van <span class="math inline">\(R\)</span>-ben<br />
<span class="math inline">\(F_R\)</span> jelentése: blokkolási tényező, <span class="math inline">\(R\)</span>-ben egy blokkon hány rekord található</p>
</section>
<section id="mennyi-b-fa-típusú-másodlagos-index-esetén-az-átlagos-keresési-költség-ha-minden-találatot-be-kell-olvasni-a-jelölések-magyarázatát-is-adjuk-meg-2-pont" class="level2">
<h2>95. Mennyi B+-fa típusú másodlagos index esetén az átlagos keresési költség, ha minden találatot be kell olvasni (a jelölések magyarázatát is adjuk meg)? (2 pont)</h2>
<p><em>14. oldal (a szelektivitást tartalmazó képlet)</em></p>
<p><span class="math inline">\(HT_i + \lceil SC(A,R) \rceil\)</span><br />
<span class="math inline">\(HT_i\)</span> jelentése: <span class="math inline">\(i\)</span> index szintjeinek száma<br />
<span class="math inline">\(SC(A,R)\)</span> jelentése: átlagosan hány <span class="math inline">\(A=a\)</span> mező van <span class="math inline">\(R\)</span>-ben</p>
</section>
</section>
<section id="költségbecslés-optimalizálás-optimization-hu.ppt" class="level1">
<h1>Költségbecslés, optimalizálás (optimization-hu.ppt)</h1>
<section id="a-sigma_theta_1-wedge-...-wedge-theta_n-lekérdezésnek-adjuk-meg-kétféle-kiszámítási-módját-6-pont" class="level2">
<h2>96. A <span class="math inline">\(\sigma_{\theta_1 \wedge ... \wedge \theta_n}\)</span> lekérdezésnek adjuk meg kétféle kiszámítási módját! (6 pont)</h2>
<p><em>15. oldal, 1. bajusz és 2. pötty, 2. bajusz és első három pötty</em></p>
<ul>
<li>Ha több <span class="math inline">\(\theta_i\)</span>-hez van indexünk, akkor indexek használatával keressük meg a hozzá tartozó feltételt kielégítő sorok azonosítóit (RID-eket) és vegyünk a RID-ek metszetét.</li>
<li>Egyébként végezzük el a legkisebb költségű <span class="math inline">\(\theta_i\)</span> kiválasztást és a fennmaradó <span class="math inline">\(\theta_i\)</span> feltételek szerint szűrjük az eredményt.</li>
</ul>
</section>
<section id="a-sigma_theta_1-lor-...-lor-theta_n-lekérdezésnek-adjuk-meg-kétféle-kiszámítási-módját-3-pont" class="level2">
<h2>97. A <span class="math inline">\(\sigma_{\theta_1 \lor ... \lor \theta_n}\)</span> lekérdezésnek adjuk meg kétféle kiszámítási módját! (3 pont)</h2>
<p><em>15. oldal, a diszjunkciós kiválasztás alatti 3 sor</em></p>
<ul>
<li>Ha több <span class="math inline">\(\theta_i\)</span>-hez van indexünk, akkor indexek használatával keressük meg a hozzá tartozó feltételt kielégítő sorok azonosítóit (RID-eket) és vegyünk a RID-ek unióját.</li>
<li>Egyébként végezzünk lineáris keresést.</li>
</ul>
</section>
<section id="milyen-adatbázis-műveletekhez-kell-rendezés-5-pont" class="level2">
<h2>98. Milyen adatbázis műveletekhez kell rendezés? (5 pont)</h2>
<p><em>16. oldal, az 5 bajusz</em></p>
<p>rendezés, unió, metszet, <span class="math inline">\(\Pi\)</span> (vetítésnél a duplikált értékek kiszűrése)</p>
</section>
<section id="milyen-két-fajtája-van-a-rendezésnek-2-pont" class="level2">
<h2>99. Milyen két fajtája van a rendezésnek? (2 pont)</h2>
<p><em>17. oldal, 3.1. 3.2</em></p>
<p>Belső és külső rendezés. Belső rendezés akkor használható, ha a rekordok egyszerre beleférnek a memóriába.</p>
</section>
<section id="külső-összefésülő-rendezésnél-mire-jó-a-rendező-lépés-1-pont" class="level2">
<h2>100. Külső összefésülő rendezésnél mire jó a rendező lépés? (1 pont)</h2>
<p><em>18. oldal, első sor</em></p>
<p>Rendezett futamok létrehozására. Egy futam egy <span class="math inline">\(M\)</span> hosszú <span class="math inline">\(R_i\)</span> fájl, ahol <span class="math inline">\(M\)</span> a memória mérete blokkokban.</p>
</section>
<section id="külső-összefésülő-rendezésnél-mire-jó-az-összevonási-lépés-1-pont" class="level2">
<h2>101. Külső összefésülő rendezésnél mire jó az összevonási lépés? (1 pont)</h2>
<p><em>19. oldal, első sor</em></p>
<p>Rendezett futamok összefésülésére. Több rendezett fájlból (futamból) készítünk egy rendezett fájlt.</p>
</section>
<section id="külső-összefésülő-rendezésnél-mikor-kell-több-menetben-végezni-az-összevonási-lépést-2-pont" class="level2">
<h2>102. Külső összefésülő rendezésnél mikor kell több menetben végezni az összevonási lépést? (2 pont)</h2>
<p><em>20. oldal, 2. pont, de a betűk magyarázata is kell</em></p>
<p>Ha a futamok száma (<span class="math inline">\(N\)</span>) meghaladja a memória méretét blokkokban kifejezve (<span class="math inline">\(M\)</span>). Azaz ha nem tudunk minden fájlhoz egy-egy külön memóriablokkot fenntartani, mert nincs elég memória. (A futam egy rendezett fájl; ezeket kell összefésülni.)</p>
<p>Valójában <span class="math inline">\(N \ge M\)</span> esetén is erre van szükség, de ha így van az előadás dián…</p>
</section>
<section id="külső-összefésülő-rendezésnél-mennyi-a-rendező-lépés-költsége-2-pont" class="level2">
<h2>103. Külső összefésülő rendezésnél mennyi a rendező lépés költsége? (2 pont)</h2>
<p><em>22. oldal, 2. pont, de a betűk magyarázata is kell</em></p>
<p><span class="math inline">\(2*B_R\)</span>, azaz a rendezendő reláció blokkokban kifejezett méretének kétszerese.</p>
</section>
<section id="külső-összefésülő-rendezésnél-mennyi-összevonandó-futam-van-kezdetben-2-pont" class="level2">
<h2>104. Külső összefésülő rendezésnél mennyi összevonandó futam van kezdetben? (2 pont)</h2>
<p><em>22. oldal, 3.1. pont, de a betűk magyarázata is kell</em></p>
<p><span class="math inline">\(\lceil B_R / M \rceil\)</span> darab futam van kezdetben, azaz a rendezendő reláció méretét elosztjuk a memória méretével és felfelé kerekítjük.</p>
</section>
<section id="külső-összefésülő-rendezésnél-mennyi-az-összes-menetek-száma-2-pont" class="level2">
<h2>105. Külső összefésülő rendezésnél mennyi az összes menetek száma? (2 pont)</h2>
<p><em>22. oldal, 3.3. pont, de a betűk magyarázata is kell</em></p>
<p><span class="math inline">\(\lceil \log_{M-1} ( B_R / M ) \rceil\)</span> menetre van szükség, ahol <span class="math inline">\(M\)</span> a memória mérete, <span class="math inline">\(B_R\)</span> pedig a rendezendő reláció mérete, mindkettő blokkokban értendő. Magyarázat: minden menet <span class="math inline">\(M-1\)</span> futamot rendez, ezért minden menetben <span class="math inline">\(M-1\)</span>-ed részére csökken a rendezendő futamok száma.</p>
</section>
<section id="külső-összefésülő-rendezésnél-mennyi-blokkot-olvasunk-minden-menetben-2-pont" class="level2">
<h2>106. Külső összefésülő rendezésnél mennyi blokkot olvasunk minden menetben? (2 pont)</h2>
<p><em>22. oldal, 3.4. pont, de a betűk magyarázata is kell</em></p>
<p>Hivatalos jegyzet:<br />
Minden menetben <span class="math inline">\(2*B_R\)</span> blokkot olvasunk, ahol <span class="math inline">\(B_R\)</span> a rendezendő reláció mérete blokkokban kifejezve.</p>
<p>Szerintem erre gondolt inkább:<br />
Minden menetben <span class="math inline">\(B_R\)</span> blokkot olvasunk és <span class="math inline">\(B_R\)</span> blokkot írunk, így egy menet költsége <span class="math inline">\(2*B_R\)</span> (ahol <span class="math inline">\(B_R\)</span> a rendezendő reláció mérete blokkokban kifejezve). Az utolsó írás az kivétel, azt nem számoljuk bele a költségbe. <span class="math inline">\(B_R\)</span> pedig valójában csak egy felső becslés (amit az utolsó menetben el is érünk).</p>
</section>
<section id="külső-összefésülő-rendezésnél-mennyi-a-teljes-költség-a-végeredmény-kiírása-nélkül-4-pont" class="level2">
<h2>107. Külső összefésülő rendezésnél mennyi a teljes költség, a végeredmény kiírása nélkül? (4 pont)</h2>
<p><em>22. oldal, 3.4. pont, de a betűk magyarázata is kell</em></p>
<p><span class="math inline">\(2*B_R + 2*B_R * \lceil \log_{M-1} (B_R / M) \rceil - B_R\)</span> ahol <span class="math inline">\(B_R\)</span> a rendezendő reláció mérete, <span class="math inline">\(M\)</span> pedig a memória mérete, mindkettő blokkokban kifejezve</p>
</section>
<section id="a-vetítés-milyen-három-lépés-megvalósításából-áll-3-pont" class="level2">
<h2>108. A vetítés milyen három lépés megvalósításából áll? (3 pont)</h2>
<p><em>23. oldal, 4. pont</em></p>
<p>Kezdeti átnézés (felesleges mezők törlése), rendezés, végső átnézés (duplikáltak törlése, amik most már szomszédosak)</p>
</section>
<section id="soroljuk-fel-az-összekapcsolás-5-megvalósítását-5-pont" class="level2">
<h2>109. Soroljuk fel az összekapcsolás 5 megvalósítását! (5 pont)</h2>
<p><em>24. oldal, 2. pont</em></p>
<ul>
<li>Skatulyázott ciklusos (nested loop) összekapcsolás</li>
<li>Blokk-skatulyázott ciklusos (block-nested loop) összekapcsolás</li>
<li>Indexelt skatulyázott ciklusos összekapcsolás</li>
<li>Összefésüléses rendező összekapcsolás</li>
<li>Hasításos összekapcsolás</li>
</ul>
</section>
<section id="skatulyázott-nestedloop-összekapcsolásnál-mennyi-a-költsége-legjobb-esetben-3-pont" class="level2">
<h2>110. Skatulyázott (NestedLoop) összekapcsolásnál mennyi a költsége legjobb esetben? (3 pont)</h2>
<p><em>25. oldal, 1.1 pont mindhárom sora</em></p>
<p>A legjobb eset akkor lép fel, ha a (kisebb) reláció elfér a memóriában. Ekkor legyen ez a belső reláció. A költség: <span class="math inline">\(B_R + B_S\)</span> (ahol <span class="math inline">\(B_X\)</span> az <span class="math inline">\(X\)</span> reláció méretét jelenti blokkokban kifejezve)</p>
</section>
<section id="skatulyázott-nestedloop-összekapcsolásnál-mennyi-a-költsége-legrosszabb-esetben-3-pont" class="level2">
<h2>111. Skatulyázott (NestedLoop) összekapcsolásnál mennyi a költsége legrosszabb esetben? (3 pont)</h2>
<p><em>25. oldal, 1.2 pont mindhárom sora</em></p>
<p>A legroszabb eset akkor lép fel, ha mindkettő relációból csak 1-1 lap fér bele a memóriába. Ekkor minden (<span class="math inline">\(R\)</span>-beli) rekordhoz végig kell olvasni a másik reláció (<span class="math inline">\(S\)</span>) összes blokkját, így a költség: <span class="math inline">\(N_R * B_S + B_R\)</span> (ahol <span class="math inline">\(B_X\)</span> az <span class="math inline">\(X\)</span> reláció méretét jelenti blokkokban kifejezve, <span class="math inline">\(N_R\)</span> pedig az <span class="math inline">\(R\)</span> relációban található rekordok számát)</p>
</section>
<section id="blokk-skatulyázott-blocknestedloop-összekapcsolásnál-mennyi-a-költség-legjobb-esetben-3-pont" class="level2">
<h2>112. Blokk-Skatulyázott (BlockNestedLoop) összekapcsolásnál mennyi a költség legjobb esetben? (3 pont)</h2>
<p><em>28. oldal, 1.1 pont mindhárom sora</em></p>
<p>A legjobb eset akkor lép fel, ha a (kisebb) reláció elfér a memóriában. Ekkor legyen ez a belső reláció. A költség: <span class="math inline">\(B_R + B_S\)</span> (ahol <span class="math inline">\(B_X\)</span> az <span class="math inline">\(X\)</span> reláció méretét jelenti blokkokban kifejezve)</p>
</section>
<section id="blokk-skatulyázott-blocknestedloop-összekapcsolásnál-mennyi-a-költség-legrosszabb-esetben-3-pont" class="level2">
<h2>113. Blokk-Skatulyázott (BlockNestedLoop) összekapcsolásnál mennyi a költség legrosszabb esetben? (3 pont)</h2>
<p><em>28. oldal, 1.2 pont mindhárom sora</em></p>
<p>A legroszabb eset akkor lép fel, ha mindkettő relációból csak 1-1 lap fér bele a memóriába. Ekkor minden (<span class="math inline">\(R\)</span>-beli) blokkhoz végig kell olvasni a másik reláció (<span class="math inline">\(S\)</span>) összes blokkját, így a költség: <span class="math inline">\(B_R * B_S + B_R\)</span> (ahol <span class="math inline">\(B_X\)</span> az <span class="math inline">\(X\)</span> reláció méretét jelenti blokkokban kifejezve)</p>
</section>
<section id="indexelt-összekapcsolásnál-mennyi-a-költség-3-pont" class="level2">
<h2>114. Indexelt összekapcsolásnál mennyi a költség? (3 pont)</h2>
<p><em>29. oldal, 4. pont mindhárom sora</em></p>
<p>Legyen <span class="math inline">\(c\)</span> a belső relációból index szerinti kiválasztás költsége, továbbá legyen a kevesebb rekordot tartalmazó reláció a külső reláció (<span class="math inline">\(R\)</span>). Ekkor a költség: <span class="math inline">\(B_R + N_R * c\)</span> (ahol <span class="math inline">\(B_R\)</span> az <span class="math inline">\(R\)</span> reláció mérete blokkokban kifejezve, <span class="math inline">\(N_R\)</span> pedig az <span class="math inline">\(R\)</span> relációban található rekordok száma)</p>
</section>
<section id="rendezéses-összefésüléses-összekapcsolásnál-mennyi-a-költség-3-pont" class="level2">
<h2>115. Rendezéses-Összefésüléses összekapcsolásnál mennyi a költség? (3 pont)</h2>
<p><em>30. oldal, 5. pont</em></p>
<p>A költség: <span class="math inline">\(\text{rendezés költsége} + B_S + B_R\)</span> (ahol <span class="math inline">\(B_X\)</span> az <span class="math inline">\(X\)</span> reláció mérete blokkokban kifejezve)</p>
</section>
<section id="hasításos-összekapcsolásnál-mennyi-a-költség-3-pont" class="level2">
<h2>116. Hasításos összekapcsolásnál mennyi a költség? (3 pont)</h2>
<p><em>31. oldal, 4. pont</em></p>
<p>A költség: <span class="math inline">\(2*(B_R + B_S) + (B_R+B_S)\)</span> (ahol <span class="math inline">\(B_X\)</span> az <span class="math inline">\(X\)</span> reláció mérete blokkokban kifejezve)</p>
</section>
<section id="hasításos-összekapcsolásnál-mekkora-méretű-kosarakat-képezünk-2-pont" class="level2">
<h2>117. Hasításos összekapcsolásnál mekkora méretű kosarakat képezünk? (2 pont)</h2>
<p><em>31. oldal, 2. pont első sora</em></p>
<p>Ami állítólag a válasz, de a kérdésre nem válaszol:<br />
Alkalmazzuk <span class="math inline">\(h_1\)</span>-et (hash függvény) az összekapcsolási mezőre és felosztjuk a rekordokat memóriában elférő részekre.</p>
<p>A választ esetleg a kosarak számának függvényében lehetne megadni, de akkor is kérdéses, hogy mennyi konstans extra memóriára van szükség. A kosarak száma pedig nem triviális és egy hash függvény nem ad garanciát arra, hogy egy fix méretű kosárba bele fog férni minden szükséges rekord.</p>
</section>
<section id="hány-sora-van-a-sigma_avr-lekérdezés-eredményének-2-pont" class="level2">
<h2>118. Hány sora van a <span class="math inline">\(\sigma_{A=v}(R)\)</span> lekérdezés eredményének? (2 pont)</h2>
<p><em>40. oldal, 1. pont</em></p>
<p><span class="math inline">\(SC(A,R)\)</span>, azaz annyi, ahány <span class="math inline">\(A=a\)</span> mező van <span class="math inline">\(R\)</span>-ben átlagosan. Ha <span class="math inline">\(A\)</span> kulcs, akkor <span class="math inline">\(SC(A,R)=1\)</span>, egyébként <span class="math inline">\(SC(A,R)=N_R/V(A,R)\)</span> (ahol <span class="math inline">\(N_R\)</span> a rekordok száma, <span class="math inline">\(V(A,R)\)</span> pedig az <span class="math inline">\(A\)</span> mező különböző értékeinek száma).</p>
</section>
<section id="hány-sora-van-a-sigma_a-le-vr-lekérdezés-eredményének-2-pont" class="level2">
<h2>119. Hány sora van a <span class="math inline">\(\sigma_{A \le v}(R)\)</span> lekérdezés eredményének? (2 pont)</h2>
<p><em>40. oldal, 2. pont</em></p>
<p><span class="math inline">\(N_R * \frac{v-\min(A,R)}{\max(A,R)-\min(A,R)}\)</span> ahol <span class="math inline">\(N_R\)</span> a rekordok száma, <span class="math inline">\(\min\)</span> és <span class="math inline">\(\max\)</span> pedig az adott mező minimális/maximális előforduló értéke.</p>
</section>
<section id="hány-sora-van-a-sigma_theta_0-wedge-...-wedge-theta_nr-lekérdezés-eredményének-2-pont" class="level2">
<h2>120. Hány sora van a <span class="math inline">\(\sigma_{\theta_0 \wedge ... \wedge \theta_n}(R)\)</span> lekérdezés eredményének? (2 pont)</h2>
<p><em>40. oldal, 3. pont</em></p>
<p><span class="math inline">\(N_R * (\frac{s_1}{N_R} * ... * \frac{s_n}{N_R})\)</span> ahol <span class="math inline">\(s_i\)</span> (<span class="math inline">\(\theta_i\)</span> szelektivitása) a rekordok száma, amik <span class="math inline">\(\theta_i\)</span>-t kielégítik (valószínűségi alapon), <span class="math inline">\(N_R\)</span> pedig a relációban lévő rekordok száma.</p>
</section>
<section id="hány-sora-van-a-sigma_theta_0-lor-...-lor-theta_nr-lekérdezés-eredményének-2-pont" class="level2">
<h2>121. Hány sora van a <span class="math inline">\(\sigma_{\theta_0 \lor ... \lor \theta_n}(R)\)</span> lekérdezés eredményének? (2 pont)</h2>
<p><em>40. oldal, 4. pont, 2. sor</em></p>
<p><span class="math inline">\(N_R * (1-[(1-\frac{s_1}{N_R}) * ... * (1-\frac{s_n}{N_R})])\)</span> ahol <span class="math inline">\(s_i\)</span> (<span class="math inline">\(\theta_i\)</span> szelektivitása) a rekordok száma, amik <span class="math inline">\(\theta_i\)</span>-t kielégítik (valószínűségi alapon), <span class="math inline">\(N_R\)</span> pedig a relációban lévő rekordok száma.</p>
</section>
<section id="hány-sora-van-az-r-times-s-lekérdezés-eredményének-2-pont" class="level2">
<h2>122. Hány sora van az <span class="math inline">\(R \times S\)</span> lekérdezés eredményének? (2 pont)</h2>
<p><em>41. oldal, 1. pont</em></p>
<p><span class="math inline">\(N_R * N_S\)</span>, ahol <span class="math inline">\(N_X\)</span> az <span class="math inline">\(X\)</span> relációban található rekordok számát adja meg</p>
</section>
<section id="hány-sora-van-az-r-bowtie-s-lekérdezés-eredményének-ha-r-cap-s-emptyset-2-pont" class="level2">
<h2>123. Hány sora van az <span class="math inline">\(R \bowtie S\)</span> lekérdezés eredményének, ha <span class="math inline">\(R \cap S = \emptyset\)</span>? (2 pont)</h2>
<p><em>41. oldal, 2.1.</em></p>
<p><span class="math inline">\(N_R * N_S\)</span>, ahol <span class="math inline">\(N_X\)</span> az <span class="math inline">\(X\)</span> relációban található rekordok számát adja meg</p>
</section>
<section id="hány-sora-van-az-r-bowtie-s-lekérdezés-eredményének-ha-r-cap-s-kulcs-r-en-2-pont" class="level2">
<h2>124. Hány sora van az <span class="math inline">\(R \bowtie S\)</span> lekérdezés eredményének, ha <span class="math inline">\(R \cap S\)</span> kulcs R-en? (2 pont)</h2>
<p><em>41. oldal, 2.2.</em></p>
<p><span class="math inline">\(N_S\)</span>, azaz az <span class="math inline">\(S\)</span> reláció sorainak száma</p>
</section>
<section id="hány-sora-van-az-r-bowtie-s-lekérdezés-eredményének-ha-r-cap-s-idegen-kulcs-r-hez-2-pont" class="level2">
<h2>125. Hány sora van az <span class="math inline">\(R \bowtie S\)</span> lekérdezés eredményének, ha <span class="math inline">\(R \cap S\)</span> idegen kulcs R-hez? (2 pont)</h2>
<p><em>41. oldal, 2.3.</em></p>
<p><span class="math inline">\(N_S\)</span>, azaz az <span class="math inline">\(S\)</span> reláció sorainak száma</p>
</section>
<section id="hány-sora-van-az-r-bowtie-s-lekérdezés-eredményének-ha-r-cap-s-a-sem-r-nek-sem-s-nek-nem-kulcsa-2-pont" class="level2">
<h2>126. Hány sora van az <span class="math inline">\(R \bowtie S\)</span> lekérdezés eredményének, ha <span class="math inline">\(R \cap S = \{A\}\)</span> sem R-nek, sem S-nek nem kulcsa? (2 pont)</h2>
<p><em>41. oldal, 2.4.</em></p>
<p><span class="math inline">\(N_R * N_S / V(A,S)\)</span>, ahol <span class="math inline">\(N_X\)</span> az <span class="math inline">\(X\)</span> reláció sorainak számát, <span class="math inline">\(V(A,S)\)</span> pedig az <span class="math inline">\(A\)</span> mező különböző értékeinek számát (<span class="math inline">\(S\)</span>-ben) adja meg.<br />
Felső becsléshez <span class="math inline">\(R\)</span> és <span class="math inline">\(S\)</span> fordítva is behelyettesíthető és a két eredmény maximumát lehet venni.</p>
</section>
</section>
<section id="összekapcsolás-sorrend-20.joinorder.ppt" class="level1">
<h1>Összekapcsolás sorrend (20.joinorder.ppt)</h1>
<section id="mi-a-szabályos-zárójelezések-számának-rekurzív-képlete-2-pont" class="level2">
<h2>127. Mi a szabályos zárójelezések számának rekurzív képlete? (2 pont)</h2>
<p><em>9. oldal, 1.2 két sora</em></p>
<p>Legyen <span class="math inline">\(T(n)\)</span> az <span class="math inline">\(n\)</span> tagú kifejezés lehetséges zárójelezéseinek száma.<br />
<span class="math inline">\(T(1) = 1\)</span><br />
<span class="math inline">\(T(n) = \sum_{i=1}^{n-1} T(i) * T(n-i)\)</span></p>
</section>
<section id="mennyi-n-tagú-join-fa-van-2-pont" class="level2">
<h2>128. Mennyi n tagú Join fa van? (2 pont)</h2>
<p><em>9. oldal, T(n)n!, ahol T(n) az n elem szabályos zárójelezéseinek száma</em></p>
<p><span class="math inline">\(T(n) * n!\)</span> darab, ahol <span class="math inline">\(T(n)\)</span> az <span class="math inline">\(n\)</span> tagú kifejezés lehetséges zárójelezéseinek száma.</p>
</section>
<section id="tagú-összekapcsolás-sorrendjének-legjobb-tervét-dinamikus-programozási-elvet-alkalmazva-hogyan-számoljuk-ki-3-pont" class="level2">
<h2>129. 5 tagú összekapcsolás sorrendjének legjobb tervét dinamikus programozási elvet alkalmazva hogyan számoljuk ki? (3 pont)</h2>
<p><em>13. oldal, 2. pont</em></p>
<p>Egy <span class="math inline">\(n-1\)</span> tagú összekapcsolás eredményéhez hozzákapcsoljuk az <span class="math inline">\(n\)</span>-edik tagok. Az <span class="math inline">\(n\)</span> lehetséges kombináció közül a legkisebb költségűt választjuk.</p>
<pre><code>BestPlan(A,B,C,D,E) = min of (
    BestPlan(A,B,C,D) |X| E,
    BestPlan(A,B,C,E) |X| D,
    BestPlan(A,B,D,E) |X| C,
    BestPlan(A,C,D,E) |X| B,
    BestPlan(B,C,D,E) |X| A
)</code></pre>
</section>
</section>
<section id="összekapcsolás-sorrend-09_qp_opt.ppt" class="level1">
<h1>Összekapcsolás sorrend (09_qp_opt.ppt)</h1>
<section id="több-tagú-összekapcsolás-suboptimális-sorrendjét-milyen-algoritmussal-lehet-előállítani-és-a-tartalmazási-hálón-milyen-irányban-halad-a-kiértékelés-2-pont" class="level2">
<h2>130. Több-tagú összekapcsolás suboptimális sorrendjét milyen algoritmussal lehet előállítani, és a tartalmazási hálón milyen irányban halad a kiértékelés? (2 pont)</h2>
<p><em>20. oldal, cím és nyíl</em></p>
<p>Az algoritmus neve “Selinger algoritmus” és a kiértékelés lentről (egyedül álló relációk szintjéről) felfelé halad (egyre több darab reláció van összekapcsolva).</p>
</section>
</section>
<section id="tétel-9-tetel9_kidolgozott.pdf" class="level1">
<h1>Tétel 9 (Tetel9_kidolgozott.pdf)</h1>
<section id="a-qab-join-rbc-join-scd-lekérdezésnek-melyik-három-kiértékelését-hasonlítottuk-össze-és-melyik-volt-a-legjobb-ezek-közül-4-pont" class="level2">
<h2>131. A <code>Q(A,B) JOIN R(B,C) JOIN S(C,D)</code> lekérdezésnek melyik három kiértékelését hasonlítottuk össze, és melyik volt a legjobb ezek közül? (4 pont)</h2>
<p><em>1. oldal a, b, c.c, volt a legjobb.</em></p>
<ol type="a">
<li>balról jobbra</li>
<li>balról jobbra és a memóriában összekapcsolva a harmadik táblával</li>
<li>középső ténytábla soraihoz kapcsolva a szélső dimenziótáblákat (ez volt a legjobb)</li>
</ol>
</section>
<section id="a-qab-join-rbc-join-scd-lekérdezésnek-három-kiértékelésénél-milyen-indexeket-tételeztünk-fel-2-pont" class="level2">
<h2>132. A <code>Q(A,B) JOIN R(B,C) JOIN S(C,D)</code> lekérdezésnek három kiértékelésénél milyen indexeket tételeztünk fel? (2 pont)</h2>
<p><em>1. oldal 2. sor</em></p>
<p>Létezik <code>Q.B</code>-re és <code>S.C</code>-re klaszterindex.</p>
</section>
<section id="az-rab-join-sbc-lekérdezés-eredményében-mennyi-a-sorok-száma-2-pont" class="level2">
<h2>133. Az <code>R(A,B) JOIN S(B,C)</code> lekérdezés eredményében mennyi a sorok száma? (2 pont)</h2>
<p><em>1. oldal 2) képlet</em></p>
<p><span class="math inline">\(T_{R \bowtie S} = T_R * T_S / I\)</span>, ahol <span class="math inline">\(T\)</span> a sorok számát, <span class="math inline">\(I\)</span> pedig az <span class="math inline">\(S.B\)</span> oszlopon előforduló különböző értékek számát jelöli.</p>
</section>
<section id="az-rab-join-sbc-lekérdezés-eredménye-hány-blokkból-áll-2-pont" class="level2">
<h2>134. Az <code>R(A,B) JOIN S(B,C)</code> lekérdezés eredménye hány blokkból áll? (2 pont)</h2>
<p><em>1. oldal 3) képlet</em></p>
<p><span class="math inline">\((T_R * B_S + T_S * B_R) / I\)</span>, ahol <span class="math inline">\(T\)</span> a sorok számát, <span class="math inline">\(B\)</span> a reláció méretét blokkokban, <span class="math inline">\(I\)</span> pedig az <span class="math inline">\(S.B\)</span> oszlopon előforduló különböző értékek számát jelöli.<br />
Megjegyzés: <span class="math inline">\(R \times S\)</span> esetén a válasz <span class="math inline">\(T_R * B_S + T_S * B_R\)</span> lenne.</p>
</section>
<section id="a-qab-join-rbc-join-scd-lekérdezésnek-balról-jobbra-a-kiértékelésénél-milyen-költségek-összege-lesz-a-teljes-költség-és-mennyi-a-teljes-költség-5-pont" class="level2">
<h2>135. A <code>Q(A,B) JOIN R(B,C) JOIN S(C,D)</code> lekérdezésnek balról jobbra (a) kiértékelésénél milyen költségek összege lesz a teljes költség, és mennyi a teljes költség? (5 pont)</h2>
<p><em>2. oldal a) a teljes JOIN I/O költsége: négy sora és a) végeredménye</em></p>
<p>Első join költsége: <span class="math inline">\(B + T*B/I\)</span><br />
Első join kiírása: <span class="math inline">\(2*T*B/I\)</span><br />
Második join költsége: <span class="math inline">\(2*T*B/I + [(T^2/I)*B]/I\)</span><br />
Második join kiírása: <span class="math inline">\(3*T^2*B/I^2\)</span><br />
Teljes költség (előzőek összeadva): <span class="math inline">\(B+5*T*B/I+4*T^2*B/I^2\)</span></p>
</section>
<section id="a-qab-join-rbc-join-scd-lekérdezésnek-balról-jobbra-b-kiértékelésénél-mennyit-lehet-megspórolni-és-mennyi-a-teljes-költség-5-pont" class="level2">
<h2>136. A <code>Q(A,B) JOIN R(B,C) JOIN S(C,D)</code> lekérdezésnek balról jobbra (b) kiértékelésénél mennyit lehet megspórolni és mennyi a teljes költség? (5 pont)</h2>
<p><em>2. oldal ab) magyarázatában szereplő képlet és b) végeredménye</em></p>
<p>Megspórolhatjuk az első join eredményének kiírását majd újboli beolvasását (<span class="math inline">\(2 * (2*T*B/I)\)</span>).<br />
Teljes költség: <span class="math inline">\(B + T*B/I + 4*T^2*B/I^2\)</span></p>
</section>
<section id="a-qab-join-rbc-join-scd-lekérdezésnek-c-kiértékelésénél-középső-ténytáblához-indexek-alapján-kapcsoljuk-a-dimenziótáblákat-milyen-költségek-összege-lesz-a-teljes-költség-és-mennyi-a-teljes-költség-4-pont" class="level2">
<h2>137. A <code>Q(A,B) JOIN R(B,C) JOIN S(C,D)</code> lekérdezésnek c) kiértékelésénél (középső ténytáblához indexek alapján kapcsoljuk a dimenziótáblákat) milyen költségek összege lesz a teljes költség, és mennyi a teljes költség? (4 pont)</h2>
<p><em>2. oldal c) három képlete és c) végeredménye</em></p>
<p>Q beolvasása: <span class="math inline">\(B\)</span><br />
Q és S olvasása <span class="math inline">\(R\)</span> minden sorára: <span class="math inline">\(T * (B/I + B/I)\)</span><br />
Eredmény kiírása: <span class="math inline">\(3 * T^2 * B/I^2\)</span><br />
Teljes költség: <span class="math inline">\(B + 2*T*B/I + 3*T^2*B/I^2\)</span></p>
</section>
<section id="a-qab-join-rbc-join-scd-lekérdezésnek-c-és-b-kiértékelésének-költségei-hogy-aránylanak-egymáshoz-és-milyen-feltétel-szükséges-ehhez-2-pont" class="level2">
<h2>138. A <code>Q(A,B) JOIN R(B,C) JOIN S(C,D)</code> lekérdezésnek c) és b) kiértékelésének költségei hogy aránylanak egymáshoz, és milyen feltétel szükséges ehhez? (2 pont)</h2>
<p><em>2. oldal utolsó két mondat.</em></p>
<p>Nagyméretű táblák esetén <span class="math inline">\(T/I\)</span> nagy lesz, ezért a négyzetes tag jóval nagyobb lesz, mint a lineáris tag, tehát a c) módszer a leghatékonyabb.</p>
<p>A <span class="math inline">\(c/b\)</span> arány <span class="math inline">\(3/4\)</span>-hez tart, ha T/I tart a végtelenbe. Vagyis ha <span class="math inline">\(T/I\)</span> elég nagy, akkor c) költsége nagyjából <span class="math inline">\(3/4\)</span>-e a b)-nek.</p>
</section>
</section>
<section id="hangolás-9ituning-hu.ppt" class="level1">
<h1>Hangolás (9ituning-hu.ppt)</h1>
<section id="a-legjobb-átfutás-mit-optimalizál-2-pont" class="level2">
<h2>139. A legjobb átfutás mit optimalizál? (2 pont)</h2>
<p><em>7. oldal, legjobb átfutáshoz tartozó 2 sor.</em></p>
<p>A cél az eredmény minden sorát minél hamarabb visszaadni. Először számolás, aztán gyors visszatérés.</p>
</section>
<section id="a-legjobb-válaszidő-mit-optimalizál-2-pont" class="level2">
<h2>140. A legjobb válaszidő mit optimalizál? (2 pont)</h2>
<p><em>7. oldal, legjobb válaszidőhöz tartozó 2 sor.</em></p>
<p>A cél az eredmény első sorát minél hamarabb visszaadni. Számolás közben már térjen vissza, ha lehetséges.</p>
</section>
<section id="adjuk-meg-a-rowid-szerkezetét-és-egy-példát-is-rá-oracle-esetében-2-pont" class="level2">
<h2>141. Adjuk meg a ROWID szerkezetét, és egy példát is rá Oracle esetében! (2 pont)</h2>
<p><em>11. és 12. oldal, alul.</em></p>
<p>Előadáson tanult: <code>&lt;Blokk&gt;.&lt;Sor&gt;.&lt;Fájl&gt;</code></p>
<p>Példa: (ezt le lehet rajzolni)<br />
Van egy fájlunk, melynek azonosítója X. A fájl 1-től sorszámozott blokkokból áll, amik 1-től sorszámozott rekordokból állnak. A ROWID-ben a blokkok és a sorok 0-tól vannak sorszámozva. Az X fájl 7. blokkjának első sorának ROWID-je: <code>00000006.0000.0000X</code></p>
<p>Gyakorlaton tanult: Base64 kódolt 18 karakter hosszú szöveg <code>OOOOOOFFFBBBBBBRRR</code> formátumban.<br />
O: adatobjektum azonosító<br />
F: fájl azonosító<br />
B: blokk azonosító<br />
R: sor azonosító</p>
</section>
<section id="mi-az-explain-plan-for-sql-utasítás-utasítás-hatása-2-pont" class="level2">
<h2>142. Mi az <code>Explain plan for &lt;SQL-utasítás&gt;</code> utasítás hatása? (2 pont)</h2>
<p><em>17. oldal első bajusz.</em></p>
<p>Elmenti a tervet (forrás sorokat és műveleteket) a <code>Plan_Table</code>-be. Majd a <code>Plan_Table</code> nézetén (vagy külső eszközön) keresztül olvasható tervet kapunk.</p>
</section>
<section id="jellemezzük-a-select-from-emp-where-rowid00004f2a.00a2.000c-utasítást-4-pont" class="level2">
<h2>143. Jellemezzük a <code>SELECT * FROM emp WHERE rowid='00004F2A.00A2.000C'</code> utasítást! (4 pont)</h2>
<p><em>26. alsó keret teljes tartalma.</em></p>
<p>Mivel <code>rowid</code> alapján keresünk, így egyetlen sor megkeresése a feladat. A <code>rowid</code>-ben foglalt blokkot be kell olvasni és ki kell szűrni a megfelelő sort (amiben a <code>rowid</code> szintén segít, hiszen a sor azonosítót is tartalmazza).</p>
<p><code>rowid</code> alapján való keresés a leggyorsabb módszer egy sor kinyerésére, de ehhez persze tudni kell a <code>rowid</code>-t előre.</p>
</section>
</section>
</body>
</html>
